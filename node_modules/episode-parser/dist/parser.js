"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var Source;
(function (Source) {
    Source["BluRay"] = "bluray";
    Source["HDTV"] = "hdtv";
    Source["WebDL"] = "webdl";
    Source["DVD"] = "dvd";
})(Source || (Source = {}));
var parsers = [
    parseEnglishLike,
    parseSceneLike,
    parseSceneLikeWithX,
    parseSceneLike000,
];
function parseEnglishLike(filename) {
    var m = filename.match(/^(.+?)([\. ])(?:((?:20|19)\d\d)\2)?Season (\d+) (Episode (\d+))?(-(\d+))?/i);
    if (m) {
        var firstEpisode = +m[6];
        var lastEpisode = m[8] ? +m[8] : firstEpisode;
        var result = __assign({ show: m[1].replace(/\./g, ' '), season: +m[4] }, (m[6]
            ? {
                episode: firstEpisode,
                episodeCount: lastEpisode - firstEpisode + 1
            }
            : {}));
        if (m[3])
            result.year = +m[3];
        parseDetails(filename.substr(m[0].length), result);
        return result;
    }
}
function parseSceneLike(filename) {
    var m = filename.match(/^(.+?)([\. ])(?:((?:20|19)\d\d)\2)?S(\d+) ?(E(\d+))?(-(E(\d+)))?/i);
    if (m) {
        var firstEpisode = +m[6];
        var lastEpisode = m[9] ? +m[9] : firstEpisode;
        var result = __assign({ show: m[1].replace(/\./g, ' '), season: +m[4] }, (m[6]
            ? {
                episode: firstEpisode,
                episodeCount: lastEpisode - firstEpisode + 1
            }
            : {}));
        if (m[3])
            result.year = +m[3];
        parseDetails(filename.substr(m[0].length), result);
        return result;
    }
}
function parseSceneLikeWithX(filename) {
    var m = filename.match(/^(.+?)([\. ])(?:((?:20|19)\d\d)\2)?(\d+)x(\d+)(-(\d+))?\2/i);
    if (m) {
        var firstEpisode = +m[5];
        var lastEpisode = m[7] ? +m[7] : firstEpisode;
        var result = {
            show: humanize(m[1]),
            season: +m[4],
            episode: firstEpisode,
            episodeCount: lastEpisode - firstEpisode + 1
        };
        if (m[3])
            result.year = +m[3];
        parseDetails(filename.substr(m[0].length), result);
        return result;
    }
}
function parseSceneLike000(filename) {
    var m = filename.match(/^(.+?)([\. ])(?:((?:20|19)\d\d)\2)?(\d\d\d+)(-(\d+))?\2/i);
    if (m) {
        var episodeStr = m[4].substr(-2);
        var firstEpisode = +episodeStr;
        var lastEpisode = m[6] ? +m[6] : firstEpisode;
        var result = {
            show: humanize(m[1]).replace(/\w\S*/g, function (txt) { return txt.charAt(0).toUpperCase() + txt.substr(1).toLowerCase(); }),
            season: +m[4].substring(0, m[4].length - episodeStr.length),
            episode: firstEpisode,
            episodeCount: lastEpisode - firstEpisode + 1
        };
        if (m[3])
            result.year = +m[3];
        parseDetails(filename.substr(m[0].length), result);
        return result;
    }
}
function humanize(str) {
    return str.replace(/\./g, ' ').replace(/(^- )|( -$)/, '');
}
function parseDetails(details, result) {
    var re = {
        quality: /(480|720|1080)[pi]/,
        source: /(hdtv|brrip|bluray|bd|dvd|dvdrip|web-?dl)/i,
        codec: /((?:h\.|x)264|(?:h\.|x)265)/i,
        other: /((?:real[\. ])?proper)/gi,
        group: /-(\w+)(?:\[\w+\])?(\....)?$/,
        extension: /\.(...)$/
    };
    var reAll = new RegExp(Object.keys(re)
        .map(function (name) { return re[name].source; })
        .join('|'), 'i');
    var reStripper = new RegExp('(.*?)(' + reAll.source + ').*$', 'i');
    var name = humanize(details.replace(reStripper, '$1')).trim();
    if (name)
        result.name = name;
    var quality = details.match(re.quality);
    if (quality)
        result.quality = +quality[1];
    var sourceMatch = details.match(re.source);
    if (sourceMatch) {
        var source = sourceMatch[0].toLowerCase();
        if (source.substr(0, 1) === 'b')
            result.source = Source.BluRay;
        if (source === 'hdtv')
            result.source = Source.HDTV;
        if (/web-?dl/.test(source))
            result.source = Source.WebDL;
        if (/dvd/i.test(source))
            result.source = Source.DVD;
    }
    var codecMatch = details.match(re.codec);
    if (codecMatch) {
        var codec = codecMatch[0].toLowerCase();
        if (codec.indexOf('264') >= 0)
            result.codec = 'x264';
        else if (codec.indexOf('265') >= 0)
            result.codec = 'x265';
        else
            result.codec = codec;
    }
    var group = details.match(re.group);
    if (group)
        result.group = group[1];
    var extension = details.match(re.extension);
    if (extension)
        result.ext = extension[1];
}
module.exports = function (filename) {
    for (var i = 0; i < parsers.length; i += 1) {
        var result = parsers[i](filename);
        if (result)
            return result;
    }
    return null;
};
